#! /usr/bin/env node
/*! @ frdl.Frdlweb.js.Compiler.es6 : no */
/*! @ frdl.Frdlweb.js.Compiler.defaultPlugin : frdlcjs */


if(typeof define !== 'function'){ 
 var define = (require('amdefine'))(module); 
}

define( ['co',  'co-prompt',  'axios', 'subarg', 'commander', 'path', 'clone', './tokenize.js', 'machina', 'fs'], 
	   function(  co, prompt, axios, subarg, program, path , clone, tokenize, machina, fs){
 'use strict'; 
 

	
var errors = [];

const packageFile = 'package.json';	
const configFile = 'frdlweb.json';	


var projectDirectory = process.cwd();
Frdlweb.prototype.projectDirectory=function(d){
	if('undefined'!==typeof d){
		projectDirectory = d;
	}
	
	return projectDirectory;
};

Frdlweb.prototype.preg_quote=preg_quote;
Frdlweb.prototype.extractTextBetween=extractTextBetween;
Frdlweb.prototype.tokenize=tokenize;
Frdlweb.prototype.resolveEXModulesLocation=resolveEXModulesLocation;


Frdlweb.prototype.readConfigFile=function(){	
var THAT =  this;
return new Promise(function(resolve, reject){
  var file = THAT.projectDirectory()  + '/' + configFile;	
 
 
try{
 
		  fs.readdir(THAT.projectDirectory() , function(err, entries){
		   if(err){
			   console.warn(err);
			    THAT.cnf=false;							
			   resolve(THAT.cnf);
			   return;
		   }
	
			  if(-1 !== entries.indexOf(configFile) ){
				  fs.readFile(file, function(err2, data2){
                        if (err2){
             
                              console.log('Error: %s', err2 );
                 
							  THAT.cnf=false;
							  resolve(THAT.cnf);
                         }else{
			   
                               THAT.cnf = JSON.parse(data2);
							   resolve(THAT.cnf);
			             }
			               
                    });
			  }else{
								  THAT.cnf=false;
							  resolve(THAT.cnf);			  
			  }
	  });
			}catch(e){
		  console.log('e: ' + e);
		}  

 
 }).catch(function(e){
     console.error(e);
 });
};	
	
	
	
Frdlweb.prototype.readPackageFile=function(){	
var THAT =  this;
return new Promise(function(resolve, reject){
  var file = THAT.projectDirectory() + '/' + packageFile;	
 
  //fs.exists(file, function(exists){
	//if(!exists){
	//	THAT.pkg = false;  
     //      console.log('Not found: %s', file );
	//}else{
   
try{
 //console.log('file: ' + file );
		  fs.readdir(THAT.projectDirectory() , function(err, entries){
		   if(err){
			   console.warn(err);
			    THAT.pkg=false;							
			   resolve(THAT.pkg);
			   return;
		   }
		///  console.log(entries);
		   // resolve(entries);
			  if(-1 !== entries.indexOf(packageFile) ){
				  fs.readFile(file, function(err2, data2){
                        if (err2){
                //throw err;
                              console.log('Error: %s', err2 );
                 //  return;
							  THAT.pkg=false;
							  resolve(THAT.pkg);
                         }else{
			     // console.log('found: %s', file );
                               THAT.pkg = JSON.parse(data2);
							   resolve(THAT.pkg);
			             }
			               
                    });
			  }else{
								  THAT.pkg=false;
							  resolve(THAT.pkg);			  
			  }
	  });
			}catch(e){
		  console.log('e: ' + e);
		}  
	  /*	   
    
	  fs.readFile(file, (err, data) => {
               if (err){
                //throw err;
                  console.log('Error: %s', err );
                 //  return;
               }else{
			     // console.log('found: %s', file );
                    THAT.pkg = JSON.parse(data);
			  }
			  resolve(THAT.pkg);
        });

		
	  fs.readdir( THAT.projectDirectory() , function(err, entries){
		   if(err){
			   console.warn(err);
			   return;
		   }
		  console.log(entries);
	  });
	*/
	//}
 //});	
 
 }).catch(function(e){
     console.error(e);
 });
};	




 program	
  .version('0.1.0')
  .description('frdl cli')
  .command('test [url]', 'test toc URL')
  .command('bundlejs [entry]', 'build javascript bundle(s)')
 ;



  var cliFlow;
  cliFlow = new machina.BehavioralFsm( {

    initialize: function( options ) {
        // your setup code goes here...
    },

    namespace: "cli-flow",

    initialState: "uninitialized",
	
     states: {
	 
        uninitialized: {
            "*": function( client ) {
                //this.deferUntilTransition( client, 'listen' );
				process.nextTick(function(){
                  cliFlow.transition( client, "fresh" );
				});
            }
        },
		
        fresh: {
            "*": function(client) {
                this.transition( client, "testing" );
            }
        },
		
        read: {
            _onEnter: function(client) {
                 this.handle( client, "in" );
            },
            "in": function(client) {
                co(function*(){
                  client.pAST = subarg(client.argv); 
                     console.log(' client.pAST ',  client.pAST );
                  return true;
               }).then(function(){
                   cliFlow.transition( client, "eval" );
               });               
               
            },
            _onExit: function(client) {
              
            }
        },

		
        eval: {
            _onEnter: function(client) {
                 this.handle( client, "parse" );
            },
            "parse": function(client) {
               co(function*(){
			       co(function*(){
                       program.parse(client.argv); 
				   }); 
                  return true;
               }).then(function(){
                  cliFlow.transition( client, "print" );
               });
            },
            _onExit: function(client) {
              
            }
        },
	
        print: {
            _onEnter: function(client) {
                 this.handle( client, "next" );
            },
            "next": function(client) {
              process.nextTick(function(){
                    cliFlow.transition( client, "listen" );
              });
            },
            _onExit: function(client) {
              
            }
        },

        listen: {
            "loop": function(client) {
                 this.emit( "loop", { 
				     status: 'Listening for incoming events' ,
				     client : client ,
				     process : process
				 });
            },
            _onExit: function(client) {
              
            }
        },

       waiting: {
            _onEnter: function(client) {
                 this.handle( client, "idle" );
            },
			
             "idle": function(client) {
                 console.log("idle");
             },
            _onExit: function(client) {
              
            }
									  
	 },
	 

       booting: {
            _onEnter: function(client) {
                this.handle( client, "invoke" );
    
                this.emit( "booting", { status: 'booting' , client : client} );
            },
            invoke:  function(client) {
                 this.transition( client, "listen" );
            },
            _onExit: function(client) {
             
            }
									  
	 },
	 
       testing: {
            _onEnter: function(client) {
                this.timer = setTimeout( function() {
                    this.handle( client, "timeout" );
                }.bind( this ), 30000 );
                this.emit( "tests", { status: 'Testing' , client : client} );
            },
            timeout: "waiting",
            _onExit: function() {
                clearTimeout( this.timer );
            }
        }
		
	 },
     invoke : function(client){
             this.transition( client, "booting" ); 
			 this.deferUntilTransition( client, 'listen' );
	        return this;
     },
     read : function(client){
             this.transition( client, "read" ); 
	        return this;
     }
 });
	
	
cliFlow.on("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
cliFlow.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
   //  console.log(data);
});

cliFlow.on("tests", function (eventName, data){
    console.log("tests happened:", eventName);
    // console.log(data);
});	
   //  cliFlow. invoke(program);
	// console.log("cliFlow", cliFlow);
	



program.on('option:verbose', function () {
  process.env.VERBOSE = this.verbose;
});

program.on('option:*', function () {
  console[(process.env.VERBOSE ? 'error' : 'warn')]('Unknown option: %s\nSee --help for a list of available option.', program.args.join(' '));
  if(process.env.VERBOSE){
     process.exit(1);
  }
});



// error on unknown commands
program.on('command:*', function () {
  console[(process.env.VERBOSE ? 'error' : 'warn')]('Invalid command: %s\nSee --help for a list of available commands.', program.args.join(' '));
  if(process.env.VERBOSE){
     process.exit(1);
  }
});


	
program.on('--help', function(){
  console.log('');
  console.log('Examples:');
  console.log('');
  console.log('  $ custom-help --help');
  console.log('  $ custom-help -h');
});
// program.addImplicitHelpCommand();	
	

program.outputHelp(function(help) {
	console.log(help);
	return help;
});
   
 return F;	
 
 function F(argv, stdout){
    var instance = new Frdlweb( process.cwd() );    
   
	
	
	if('string'===typeof argv){
	   argv = tokenize(argv);	
	}
	 
   instance.argv = argv;

   var res = co(function*(){
   
       var configs = Promise.all([instance.readPackageFile(), instance.readConfigFile()])
			.then(function(cnfs){		
	                 var i = cliFlow.invoke(instance);
					 configs = cnfs; 
            }).catch(function(e){
			        console.warn('e', e);
			});
	   yield configs;
	   

        
	  //   console.log('configs', typeof configs);


           cliFlow.read(instance);
	   
        return errors;/* new Promise(function(yes,no){
                          yes(true);
                       });*/
   }).then(function(errors){
     if(0===errors.length){
         return '';
     }else{
         return errors.join('\n');
      }
   });

 }
 
 
 
 
 function Frdlweb(dir){
	this.pkg = false; 
	this.cnf = false; 
	this.projectDirectory(dir);
 }




function filter_boolean(value) {
		if('boolean' === typeof value)return value;
		if('undefined' === typeof value)return true;
		if(1 === value || '1' === value || 'true' === value.toLowerCase() ||  'yes' === value.toLowerCase() ||  'on' === value.toLowerCase() ){
		  return true;			 
		}
					 
		if(0 === value || '0' === value || 'false' === value.toLowerCase() ||  'no' === value.toLowerCase() ||  'off' === value.toLowerCase()	){
		  return true;			 
		}
					 
	//  if(value.length != 1) throw "Filter mismatch.";
	  return true === value;
}



function preg_quote (str, delimiter) {


    // Quote regular expression characters plus an optional character  
    // 
    // version: 1107.2516
    // discuss at: http://phpjs.org/functions/preg_quote
    // +   original by: booeyOH
    // +   improved by: Ates Goral (http://magnetiq.com)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   bugfixed by: Onno Marsman
    // +   improved by: Brett Zamir (http://brett-zamir.me)
    // *     example 1: preg_quote("$40");
    // *     returns 1: '\$40'
    // *     example 2: preg_quote("*RRRING* Hello?");
    // *     returns 2: '\*RRRING\* Hello\?'
    // *     example 3: preg_quote("\\.+*?[^]$(){}=!<>|:");
    // *     returns 3: '\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:'
    
    return (str + '').replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&')
               //     .replace(/(\s)/, "\s")
;
}


function extractTextBetween(subject, start, end) {
    try{
        return subject.split(start)[1].split(end)[0];
    } catch(e){
        console.log("Exception when extracting text", e);
    }
}
	
	
function resolveEXModulesLocation() {
   var paths = [];
   var allowOnePath = false;
   if(process.env.NODE_PATH){
       paths = process.env.NODE_PATH.split(':');
   }
   if(process.argv.length > 2){
       for(var i=2; i<process.argv.length; i++){
           if(process.argv[i] === '--prefix' && i<process.argv.length-1){
               return process.argv[i+1];
           }
           if(process.argv[i] === '---allowOnePath'){
               allowOnePath = true;
           }
       }
   }
			
			/*
   if(!paths || paths.length === 0 || (paths.length === 1 && !allowOnePath) ) {
       console.log('NODE_PATH is either empty or contain only one entry which is the global node modules location. ' +
           'If you like to use that entry specify --allowOnePath in the script arguments');
       return './';
   }
*/
   return paths[0];
}
	
	
	
function exit(){
 if('function'===typeof process.exit){	
   process.exit.apply(process,  Array.prototype.splice(arguments));
 }
}




 
 
 
 
 
});
  
  

 
 
